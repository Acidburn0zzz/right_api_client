= RightScale API Client

== Background
This gem aims to simplify working with the RigthScale API 1.5 (currently the latest version).
The RightScale API documentation is available at: http://support.rightscale.com/12-Guides/RightScale_API_1.5
API Reference Docs: http://support.rightscale.com/api1.5/

== Installation
- right_api_client uses Ruby 1.9.2 but should also work with 1.8.7. Install the gems:
    gem install rest-client (this gem is used by right_api_client)
    gem install right_api_client

== Versioning
- The right_api_client gem is versioned with the usual X.Y.Z notation, where X.Y is the RightScale API version, and Z is the client version.

== Usage Instructions
- New users can start with the following lines of code and navigate their way around the API by following the available methods:
    require 'right_api_client'
    client = RightApi::Client.new(:email => 'my@email.com', :password => 'my_password', :account_id => 'my_account_id')
    puts 'Available methods:', client.api_methods

You can find your account number by logging into RightScale > Settings > Account Settings,
the account number is at the end of the browser address bar.


-----------------------------------------------------------------------------------
The Idea Behind The RightScale API Client for Ruby:

The client makes working with and getting to know the API much easier. It spiders the API dynamically to discover its resources on the fly. At every step, the user has the ability to query api_methods() that indicates the potential methods that can be called.

To start:
 * create a client object:
    client = RightApi::Client.new(:email => 'my@email.com', :password => 'my_password', :account_id => 'my_account_id')
    client.api_methods will return all methods that you can call

To make an API call:
Essentially, just following the RightScale API documentation (available from http://support.rightscale.com):

Examples:
   - Index:     /api/clouds/:cloud_id/datacenters             =>  client.clouds(:id => :cloud_id).show.datacenters.index
   - Show:      /api/clouds/:cloud_id/datacenters/:id         =>  client.clouds(:id => :cloud_id).show.datacenters(:id => :datacenter_id).show
   - Create:    /api/deployments/:deployment_id/servers       =>  client.deployments(:id => :deployment_id).show.servers.create
   - Update:    /api/deployments/:deployment_id/servers/:id   =>  client.deployments(:id => :deployment_id).show.servers(:id => :server_id).update
   - Destroy:   /api/deployments/:deployment_id/servers/:id   =>  client.deployments(:id => :deployment_id).show.servers(:id => :server_id).destroy
   - An action: /api/servers/:server_id/launch                =>  client.servers(:id => :server_id).show.launch

As seen above, whenever you need to specify an id, you must call .show before specifying the next method (unless the id is at the very end).


When to put the parameters? Pass in the parameters to the method that they belong to:
 Lets say we want to filter on the index for deployments:
   @client.deployments.index(:filter => ['name==my_deployment'])
   The filter is the parameter for the index call and not the deployment call

The API client returns three types of objects:
  Resources, Resource and ResourceDetail

 * A Resources object will be returned when you are querying a collection of resources  (ie: client.deployments)
 * A Resource will be returned when you specify an id and therefore a specific resource (ie: client.deployments(:id => :deployment_id))
   - When the Content-type is type=collection then an array of Resource objects will be returned (ie: client.deployments.index)
   - When the Content-type is not a collection then a Resource object will be returned (ie: client.deployments(:id => deployment_id).show)
 * A ResourceDetail will be returned when you do a .show on a Resource (ie: client.deployments(:id => deployment_id).show)
 On all three types of objects you can query .api_methods

 Exceptions:
 - inputs.index will return an array of ResourceDetail objects since you cannot do a .show on an input
 - session.index will return a ResourceDetail object since you cannot do a .show on a session
 - tags.by_resource, tags.by_tag will return an array of ResourceDetail objects since you cannot do a .show on a resource_tag
 - monitoring_metrics(:id => :m_m_id).show.data will return a ResourceDetail object since you cannot do a .show on a monitoring_metric_data


For a POST with HTTP response code: 201, 202 the client will actually return the Resource object that was created and not just the href


Instance-Facing-Calls:
The client also supports instance-facing-calls, which uses the instance_token to login.
Unlike regular email-password login, instance-facing-calls are limited in the amount of allowable calls.
Since in most of the cases, the calls are scoped to the instance's cloud (or the instance itself), the cloud_id and the instance_id will be automatically recorded by the client, so that the user does not need to specify it.

Examples:
instance_client = RightApi::Client.new(:instance_token => 'my_token', :account_id => 'my_account_id')
instance_client.volume_attachments     links to /api/clouds/:cloud_id/volume_attachments
instance_client.volumes_snapshots      links to /api/clouds/:cloud_id/volumes_snapshots
instance_client.volumes_types          links to /api/clouds/:cloud_id/volumes_types
instance_client.volumes                links to /api/clouds/:cloud_id/volumes

instance_client.backups                links to /api/backups
instance_client.live_tasks(:id)        links to /api/clouds/:cloud_id/instances/:instance_id/live/tasks/:id

Note:
 * For volume_attachments and volumes_snapshots you can also go through the volume (ie: instance_client.volumes(:id => volume_id).show.volume_attachments will map to:
           /api/clouds/:cloud_id/volumes/:volume_id/volume_attachment)
 * For volume_attachments there is a third url: /api/clouds/:cloud_id/instances/:instance_id/volume_attachments. To access this do:
          instance_client.get_instance.volume_attachments

Because the cloud_id and the instance_id are automatically added by the client, scripts that work for regular email-password login will have to be modified for instance-facing-calls.
The main reason behind this design choice was the inability for instance-facing-calls to access the resource clouds, instances (ie: they cannot do a .show on clouds: instance_client.clouds(:id=> :cloud_id).show)

When you query api_methods(), it will list all of the methods that one sees with regular email-password login.
Due to the limiting scope of the instance-token only a subset of these methods can be called. (See API documentation for valid methods).
If you call a invalid method you will get: 403, Permission denied

== Logging HTTP requests
The HTTP calls made by right_api_client can be logged in two ways:
1. Log to a file
    @client.log('~/right_api_client.log')
2. Log to SDTOUT
    @client.log(STDOUT)


== Examples
Get a list of all servers (aka doing an Index call)
    @client.servers.index

Get a list of all servers in a deployment
    @client.deployments(:id => 'my_deployment_id').show.servers.index

Get a particular server (aka doing a Show call)
    @client.servers(:id => 'my_server_id').show

Creating a server involves setting up the required parameters, then calling the create method
    server_template_href = @client.server_templates.index(:filter => ['name==Base ServerTemplate']).first.href
    cloud = @client.clouds(:id => 'my_cloud_id').show
    params = { :server => {
        :name => 'Test Server',
        :deployment_href => @client.deployments(:id => 'my_deployment_id').show.href,
        :instance => {
            :server_template_href => server_template_href,
            :cloud_href           => cloud.href,
            :security_group_hrefs => [cloud.security_groups.index(:filter => ['name==default']).first.href],
            :ssh_key_href         => cloud.ssh_keys.index.first.href,
            :datacenter_href      => cloud.datacenters.index.first.href
        }}}
    new_server = @client.servers.create(params)
    new_server.api_methods

Launch the newly created server. Inputs are a bit tricky so they have to be set in a long string
    inputs = "inputs[][name]=NAME1&inputs[][value]=text:VALUE1&inputs[][name]=NAME2&inputs[][value]=text:VALUE2"
    new_server.show.launch(inputs)

Run a script on the server. The API does not currently expose right_scripts, hence, the script href has
to be retrieved from the dashboard and put in the following href format.
    script_href = "right_script_href=/api/right_scripts/382371"
    task = new_server.show.current_instance.show.run_executable(script_href + "&inputs[][name]=TEST_NAME&inputs[][value]=text:VALUE1")
    task.show.api_methods

Update the server's name
    params = { :server => {:name => 'New Server Name'}}
    @client.servers(:id => 1033656).update(params)

Terminate the server (i.e. shutdown its current_instance)
    @client.servers(:id => 'my_server_id').show.terminate

Destroy the server (i.e. delete it)
    @client.servers(:id => 'my_server_id').destroy


== Design Docs (work-in-progress)
Design Decisions:

In the code, we only hard code CRUD operations for resources. We use the .show and .index methods to make the client more efficient. Since it dynamically creates methods it needs to query the API at times. The .show and the .index make it explicit that querying needs to take place. Without them a GET would have to be queried every step of the way. (ie: the index call would be client.deployments, and the create call would be client.deployments.create which would first do an index call).

Special Cases:

Special case: Returning resource_types that are not actual API resources:
  * tags:
     - by_resource, by_tag  : both return a COLLECTION of resource_type = RESOURCE_TAG
        . no show or index is defined for that resource_type, therefore return a collection of ResourceDetail objects

  * data:
    - querying .data for monitoring_metrics:
         . no show is defined for that resource_type, therefore return a ResourceDetail object

Special case: index call does not act like an index call
  * session:
    - session.index should act like a show call and not like an index call (since you cannot query show): therefore it should return a ResourceDetail object

  * inputs
    - inputs.index cannot return a collection of Resource objects since .show is not allowed:  therefore it should return a collection of ResourceDetail object

Special case: Having a resource_type that cannot be accurately determined from the URL:
  * In server_arrays show: resource_type = current_instance(s) (although it should be instance(s))
  * In multi_cloud_images show: resource_type = setting(s) (although it should be multi_cloud_image_setting)
  * Put these in: INCONSISTENT_RESOURCE_TYPES

Special case: method defined on the generic resource_type itself
   * 'instances' => {:multi_terminate => 'do_post', :multi_run_executable => 'do_post'},
   * 'inputs'    => {:multi_update => 'do_put'},
   * 'tags'      => {:by_tag => 'do_post', :by_resource => 'do_post', :multi_add => 'do_post', :multi_delete =>'do_post'},
   * 'backups'   => {:cleanup => 'do_post'}
   * Put these in RESOURCE_TYPE_SPECIAL_ACTIONS

Special case: resources are not linked together
   * In ResourceDetail resource_type = Instance, need live_tasks as a method

Note:
  * In general, when a new API resource is added you need to indicate in the Client whether index, show, create, update and delete methods are allowed for that resource